{"version":3,"sources":["../../src/components/AudioRenderer.tsx","../../src/components/ControlButton.tsx","../../src/components/AudioSelectButton.tsx","../../node_modules/babel-plugin-transform-async-to-promises/helpers.js","../../src/useParticipant.ts","../../src/components/ControlsView.tsx","../../src/components/VideoRenderer.tsx","../../src/components/ParticipantView.tsx","../../src/components/ScreenShareView.tsx","../../src/components/desktop/DesktopStage.tsx","../../src/components/mobile/MobileStage.tsx","../../src/components/StageView.tsx","../../src/components/VideoSelectButton.tsx","../../src/useRoom.ts","../../src/LiveKitRoom.tsx","PreJoinPage.tsx","RoomPage.tsx","App.tsx","index.tsx"],"names":["AudioRenderer","track","isLocal","audioEl","useRef","useEffect","el","ControlButton","label","disabled","onClick","icon","className","menuItems","onMenuItemClick","useState","menuVisible","setMenuVisible","classes","styles","menu","React","menuTrigger","dropdown","separator","height","faChevronDown","popoverMenu","list","key","i","item","handleMenuClick","isOpen","positions","content","buttonWrapper","AudioSelectButton","isMuted","onSourceSelected","sources","setSources","setMenuItems","navigator","audioDevices","devices","faMicrophone","device","d","Symbol","iterator","asyncIterator","_catch","body","recover","result","e","then","useParticipant","participant","setMuted","isSpeaking","setSpeaking","metadata","setMetadata","publications","setPublications","subscribedTracks","setSubscribedTracks","onPublicationsChanged","Array","pub","onMuted","Track","onUnmuted","onMetadataChanged","onIsSpeakingChanged","ParticipantEvent","muted","unpublishTrack","Error","ControlsView","room","enableScreenShare","enableAudio","enableVideo","onLeave","audioPub","val","videoPub","screenPub","muteButton","faMicrophoneSlash","createLocalAudioTrack","audioTrack","videoButton","faVideo","faVideoSlash","createLocalVideoTrack","videoTrack","screenButton","faStop","faDesktop","video","width","VideoPresets","captureStream","name","videoEncoding","maxBitrate","maxFramerate","controlsWrapper","dangerButton","VideoRenderer","objectFit","ref","isFrontFacing","style","transform","ParticipantView","aspectWidth","aspectHeight","displayName","showOverlay","quality","adaptiveVideo","onMouseEnter","onMouseLeave","useInView","inView","setVideoPub","videoEnabled","setVideoEnabled","callbackTimeout","setCallbackTimeout","enabled","newVideoPub","clearTimeout","setTimeout","VideoQuality","containerStyles","mainElement","placeholder","ratio","participantBar","iconNormal","ScreenShareView","screenShare","DesktopStage","roomState","participantRenderer","controlRenderer","isConnecting","error","participants","setShowOverlay","ParticipantRenderer","ControlRenderer","p","screenTrack","otherParticipants","mainView","identity","HIGH","MobileStage","MEDIUM","StageView","stageProps","useMediaQuery","query","sid","VideoSelectButton","isEnabled","videoDevices","sortParticipants","localParticipant","a","b","aLast","aVideo","localIdx","LiveKitRoom","url","token","connectOptions","stageRenderer","onConnected","options","setRoom","setIsConnecting","setError","setParticipants","audioTracks","setAudioTracks","sortFunc","connect","useCallback","onParticipantsChanged","remotes","newRoom","onSubscribedTrackChanged","tracks","RoomEvent","useRoom","PreJoinPage","setUrl","setToken","simulcast","setSimulcast","audioEnabled","setAudioEnabled","connectDisabled","setConnectDisabled","videoRef","setVideoTrack","audioDevice","setAudioDevice","videoDevice","setVideoDevice","history","useHistory","current","videoEl","attach","detach","stop","toggleVideo","undefined","deviceId","videoElement","type","value","onChange","target","checked","mediaStreamTrack","getSettings","faBolt","window","location","protocol","startsWith","params","audioDeviceId","videoDeviceId","push","pathname","search","URLSearchParams","toString","alert","href","RoomPage","numParticipants","setNumParticipants","useLocation","get","recorder","updateParticipantSize","size","faUserFriends","on","ParticipantConnected","ParticipantDisconnected","parseInt","console","log","onParticipantDisconnected","currentRoom","isSet","publishTrack","captureOptions","publishOptions","App","path","ReactDOM","render","document","getElementById"],"mappings":"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","file":"static/js/main.80c13eb1.chunk.js","sourcesContent":["import { Track } from \"livekit-client\";\nimport { useEffect, useRef } from \"react\";\n\nexport interface AudioTrackProps {\n  track: Track;\n  isLocal: boolean;\n}\n\nexport const AudioRenderer = ({ track, isLocal }: AudioTrackProps) => {\n  const audioEl = useRef<HTMLAudioElement>();\n\n  useEffect(() => {\n    if (isLocal) {\n      // don't play own audio\n      return;\n    }\n    audioEl.current = track.attach();\n    if (track.sid) {\n      audioEl.current.setAttribute(\"data-audio-track-id\", track.sid);\n    }\n    return () => track.detach().forEach((el) => el.remove());\n  }, [track, isLocal]);\n\n  // TODO: allow set sink id\n  return null;\n};\n","import { IconProp } from \"@fortawesome/fontawesome-svg-core\";\nimport { faChevronDown } from \"@fortawesome/free-solid-svg-icons\";\nimport { FontAwesomeIcon } from \"@fortawesome/react-fontawesome\";\nimport React, { ReactElement, useState } from \"react\";\nimport { Popover } from \"react-tiny-popover\";\nimport styles from \"./styles.module.css\";\n\ninterface ButtonProps {\n  label: string;\n  disabled?: boolean;\n  onClick?: () => void;\n  icon?: IconProp;\n  className?: string;\n  menuItems?: MenuItem[];\n  onMenuItemClick?: (item: MenuItem) => void;\n}\n\nexport interface MenuItem {\n  label: string;\n}\n\nexport const ControlButton = ({\n  label,\n  disabled,\n  onClick,\n  icon,\n  className,\n  menuItems,\n  onMenuItemClick,\n}: ButtonProps) => {\n  const [menuVisible, setMenuVisible] = useState(false);\n\n  let classes = styles.button;\n  if (className) {\n    classes += ` ${className}`;\n  }\n\n  const handleMenuClick = (item: MenuItem) => {\n    if (onMenuItemClick) {\n      onMenuItemClick(item);\n    }\n    setMenuVisible(false);\n  };\n\n  let menuTrigger: ReactElement | undefined;\n  let menu: ReactElement = <div />;\n  if (menuItems && menuItems.length > 0) {\n    classes += ` ${styles.hasDropdown}`;\n    menuTrigger = (\n      <button\n        disabled={disabled}\n        className={`${styles.button} ${styles.dropdown}`}\n        onClick={() => setMenuVisible(!menuVisible)}\n      >\n        <div className={styles.separator} />\n        <FontAwesomeIcon height={32} icon={faChevronDown} />\n      </button>\n    );\n\n    menu = (\n      <div className={styles.popoverMenu}>\n        <ul className={styles.list}>\n          {menuItems?.map((item, i) => {\n            return (\n              <li key={i} onClick={() => handleMenuClick(item)}>\n                {item.label}\n              </li>\n            );\n          })}\n        </ul>\n      </div>\n    );\n  }\n\n  return (\n    <Popover isOpen={menuVisible} positions={[\"top\"]} content={menu}>\n      <div className={styles.buttonWrapper}>\n        <button disabled={disabled} className={classes} onClick={onClick}>\n          {icon && (\n            <FontAwesomeIcon className={styles.icon} height={32} icon={icon} />\n          )}\n          {label}\n        </button>\n        {menuTrigger}\n      </div>\n    </Popover>\n  );\n};\n","import {\n  faMicrophone,\n  faMicrophoneSlash,\n} from \"@fortawesome/free-solid-svg-icons\";\nimport React, { useEffect, useState } from \"react\";\nimport { ControlButton, MenuItem } from \"./ControlButton\";\n\nexport interface AudioSelectButtonProps {\n  isMuted: boolean;\n  onClick?: () => void;\n  onSourceSelected?: (device: MediaDeviceInfo) => void;\n}\n\nexport const AudioSelectButton = ({\n  isMuted,\n  onClick,\n  onSourceSelected,\n}: AudioSelectButtonProps) => {\n  const [sources, setSources] = useState<MediaDeviceInfo[]>([]);\n  const [menuItems, setMenuItems] = useState<MenuItem[]>([]);\n\n  useEffect(() => {\n    navigator.mediaDevices.enumerateDevices().then((devices) => {\n      const audioDevices = devices.filter(\n        (item) => item.kind === \"audioinput\" && item.deviceId\n      );\n      setSources(audioDevices);\n      setMenuItems(\n        audioDevices.map((item) => {\n          return { label: item.label };\n        })\n      );\n    });\n  }, [isMuted]);\n\n  const handleMenuItem = (item: MenuItem) => {\n    const device = sources.find((d) => d.label === item.label);\n    if (device && onSourceSelected) {\n      onSourceSelected(device);\n    }\n  };\n\n  return (\n    <ControlButton\n      label={isMuted ? \"Unmute\" : \"Mute\"}\n      icon={isMuted ? faMicrophoneSlash : faMicrophone}\n      onClick={onClick}\n      menuItems={menuItems}\n      onMenuItemClick={handleMenuItem}\n    />\n  );\n};\n","// A type of promise-like that resolves synchronously and supports only one observer\nexport const _Pact = /*#__PURE__*/(function() {\n\tfunction _Pact() {}\n\t_Pact.prototype.then = function(onFulfilled, onRejected) {\n\t\tconst result = new _Pact();\n\t\tconst state = this.s;\n\t\tif (state) {\n\t\t\tconst callback = state & 1 ? onFulfilled : onRejected;\n\t\t\tif (callback) {\n\t\t\t\ttry {\n\t\t\t\t\t_settle(result, 1, callback(this.v));\n\t\t\t\t} catch (e) {\n\t\t\t\t\t_settle(result, 2, e);\n\t\t\t\t}\n\t\t\t\treturn result;\n\t\t\t} else {\n\t\t\t\treturn this;\n\t\t\t}\n\t\t}\n\t\tthis.o = function(_this) {\n\t\t\ttry {\n\t\t\t\tconst value = _this.v;\n\t\t\t\tif (_this.s & 1) {\n\t\t\t\t\t_settle(result, 1, onFulfilled ? onFulfilled(value) : value);\n\t\t\t\t} else if (onRejected) {\n\t\t\t\t\t_settle(result, 1, onRejected(value));\n\t\t\t\t} else {\n\t\t\t\t\t_settle(result, 2, value);\n\t\t\t\t}\n\t\t\t} catch (e) {\n\t\t\t\t_settle(result, 2, e);\n\t\t\t}\n\t\t};\n\t\treturn result;\n\t}\n\treturn _Pact;\n})();\n\n// Settles a pact synchronously\nexport function _settle(pact, state, value) {\n\tif (!pact.s) {\n\t\tif (value instanceof _Pact) {\n\t\t\tif (value.s) {\n\t\t\t\tif (state & 1) {\n\t\t\t\t\tstate = value.s;\n\t\t\t\t}\n\t\t\t\tvalue = value.v;\n\t\t\t} else {\n\t\t\t\tvalue.o = _settle.bind(null, pact, state);\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\tif (value && value.then) {\n\t\t\tvalue.then(_settle.bind(null, pact, state), _settle.bind(null, pact, 2));\n\t\t\treturn;\n\t\t}\n\t\tpact.s = state;\n\t\tpact.v = value;\n\t\tconst observer = pact.o;\n\t\tif (observer) {\n\t\t\tobserver(pact);\n\t\t}\n\t}\n}\n\nexport function _isSettledPact(thenable) {\n\treturn thenable instanceof _Pact && thenable.s & 1;\n}\n\n// Converts argument to a function that always returns a Promise\nexport function _async(f) {\n\treturn function() {\n\t\tfor (var args = [], i = 0; i < arguments.length; i++) {\n\t\t\targs[i] = arguments[i];\n\t\t}\n\t\ttry {\n\t\t\treturn Promise.resolve(f.apply(this, args));\n\t\t} catch(e) {\n\t\t\treturn Promise.reject(e);\n\t\t}\n\t}\n}\n\n// Awaits on a value that may or may not be a Promise (equivalent to the await keyword in ES2015, with continuations passed explicitly)\nexport function _await(value, then, direct) {\n\tif (direct) {\n\t\treturn then ? then(value) : value;\n\t}\n\tif (!value || !value.then) {\n\t\tvalue = Promise.resolve(value);\n\t}\n\treturn then ? value.then(then) : value;\n}\n\n// Awaits on a value that may or may not be a Promise, then ignores it\nexport function _awaitIgnored(value, direct) {\n\tif (!direct) {\n\t\treturn value && value.then ? value.then(_empty) : Promise.resolve();\n\t}\n}\n\n// Proceeds after a value has resolved, or proceeds immediately if the value is not thenable\nexport function _continue(value, then) {\n\treturn value && value.then ? value.then(then) : then(value);\n}\n\n// Proceeds after a value has resolved, or proceeds immediately if the value is not thenable\nexport function _continueIgnored(value) {\n\tif (value && value.then) {\n\t\treturn value.then(_empty);\n\t}\n}\n\n// Asynchronously iterate through an object that has a length property, passing the index as the first argument to the callback (even as the length property changes)\nexport function _forTo(array, body, check) {\n\tvar i = -1, pact, reject;\n\tfunction _cycle(result) {\n\t\ttry {\n\t\t\twhile (++i < array.length && (!check || !check())) {\n\t\t\t\tresult = body(i);\n\t\t\t\tif (result && result.then) {\n\t\t\t\t\tif (_isSettledPact(result)) {\n\t\t\t\t\t\tresult = result.v;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tresult.then(_cycle, reject || (reject = _settle.bind(null, pact = new _Pact(), 2)));\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (pact) {\n\t\t\t\t_settle(pact, 1, result);\n\t\t\t} else {\n\t\t\t\tpact = result;\n\t\t\t}\n\t\t} catch (e) {\n\t\t\t_settle(pact || (pact = new _Pact()), 2, e);\n\t\t}\n\t}\n\t_cycle();\n\treturn pact;\n}\n\n// Asynchronously iterate through an object's properties (including properties inherited from the prototype)\n// Uses a snapshot of the object's properties\nexport function _forIn(target, body, check) {\n\tvar keys = [];\n\tfor (var key in target) {\n\t\tkeys.push(key);\n\t}\n\treturn _forTo(keys, function(i) { return body(keys[i]); }, check);\n}\n\n// Asynchronously iterate through an object's own properties (excluding properties inherited from the prototype)\n// Uses a snapshot of the object's properties\nexport function _forOwn(target, body, check) {\n\tvar keys = [];\n\tfor (var key in target) {\n\t\tif (Object.prototype.hasOwnProperty.call(target, key)) {\n\t\t\tkeys.push(key);\n\t\t}\n\t}\n\treturn _forTo(keys, function(i) { return body(keys[i]); }, check);\n}\n\nexport const _iteratorSymbol = /*#__PURE__*/ typeof Symbol !== \"undefined\" ? (Symbol.iterator || (Symbol.iterator = Symbol(\"Symbol.iterator\"))) : \"@@iterator\";\n\n// Asynchronously iterate through an object's values\n// Uses for...of if the runtime supports it, otherwise iterates until length on a copy\nexport function _forOf(target, body, check) {\n\tif (typeof target[_iteratorSymbol] === \"function\") {\n\t\tvar iterator = target[_iteratorSymbol](), step, pact, reject;\n\t\tfunction _cycle(result) {\n\t\t\ttry {\n\t\t\t\twhile (!(step = iterator.next()).done && (!check || !check())) {\n\t\t\t\t\tresult = body(step.value);\n\t\t\t\t\tif (result && result.then) {\n\t\t\t\t\t\tif (_isSettledPact(result)) {\n\t\t\t\t\t\t\tresult = result.v;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tresult.then(_cycle, reject || (reject = _settle.bind(null, pact = new _Pact(), 2)));\n\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (pact) {\n\t\t\t\t\t_settle(pact, 1, result);\n\t\t\t\t} else {\n\t\t\t\t\tpact = result;\n\t\t\t\t}\n\t\t\t} catch (e) {\n\t\t\t\t_settle(pact || (pact = new _Pact()), 2, e);\n\t\t\t}\n\t\t}\n\t\t_cycle();\n\t\tif (iterator.return) {\n\t\t\tvar _fixup = function(value) {\n\t\t\t\ttry {\n\t\t\t\t\tif (!step.done) {\n\t\t\t\t\t\titerator.return();\n\t\t\t\t\t}\n\t\t\t\t} catch(e) {\n\t\t\t\t}\n\t\t\t\treturn value;\n\t\t\t}\n\t\t\tif (pact && pact.then) {\n\t\t\t\treturn pact.then(_fixup, function(e) {\n\t\t\t\t\tthrow _fixup(e);\n\t\t\t\t});\n\t\t\t}\n\t\t\t_fixup();\n\t\t}\n\t\treturn pact;\n\t}\n\t// No support for Symbol.iterator\n\tif (!(\"length\" in target)) {\n\t\tthrow new TypeError(\"Object is not iterable\");\n\t}\n\t// Handle live collections properly\n\tvar values = [];\n\tfor (var i = 0; i < target.length; i++) {\n\t\tvalues.push(target[i]);\n\t}\n\treturn _forTo(values, function(i) { return body(values[i]); }, check);\n}\n\nexport const _asyncIteratorSymbol = /*#__PURE__*/ typeof Symbol !== \"undefined\" ? (Symbol.asyncIterator || (Symbol.asyncIterator = Symbol(\"Symbol.asyncIterator\"))) : \"@@asyncIterator\";\n\n// Asynchronously iterate on a value using it's async iterator if present, or its synchronous iterator if missing\nexport function _forAwaitOf(target, body, check) {\n\tif (typeof target[_asyncIteratorSymbol] === \"function\") {\n\t\tvar pact = new _Pact();\n\t\tvar iterator = target[_asyncIteratorSymbol]();\n\t\titerator.next().then(_resumeAfterNext).then(void 0, _reject);\n\t\treturn pact;\n\t\tfunction _resumeAfterBody(result) {\n\t\t\tif (check && check()) {\n\t\t\t\treturn _settle(pact, 1, iterator.return ? iterator.return().then(function() { return result; }) : result);\n\t\t\t}\n\t\t\titerator.next().then(_resumeAfterNext).then(void 0, _reject);\n\t\t}\n\t\tfunction _resumeAfterNext(step) {\n\t\t\tif (step.done) {\n\t\t\t\t_settle(pact, 1);\n\t\t\t} else {\n\t\t\t\tPromise.resolve(body(step.value)).then(_resumeAfterBody).then(void 0, _reject);\n\t\t\t}\n\t\t}\n\t\tfunction _reject(error) {\n\t\t\t_settle(pact, 2, iterator.return ? iterator.return().then(function() { return error; }) : error);\n\t\t}\n\t}\n\treturn Promise.resolve(_forOf(target, function(value) { return Promise.resolve(value).then(body); }, check));\n}\n\n// Asynchronously implement a generic for loop\nexport function _for(test, update, body) {\n\tvar stage;\n\tfor (;;) {\n\t\tvar shouldContinue = test();\n\t\tif (_isSettledPact(shouldContinue)) {\n\t\t\tshouldContinue = shouldContinue.v;\n\t\t}\n\t\tif (!shouldContinue) {\n\t\t\treturn result;\n\t\t}\n\t\tif (shouldContinue.then) {\n\t\t\tstage = 0;\n\t\t\tbreak;\n\t\t}\n\t\tvar result = body();\n\t\tif (result && result.then) {\n\t\t\tif (_isSettledPact(result)) {\n\t\t\t\tresult = result.s;\n\t\t\t} else {\n\t\t\t\tstage = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (update) {\n\t\t\tvar updateValue = update();\n\t\t\tif (updateValue && updateValue.then && !_isSettledPact(updateValue)) {\n\t\t\t\tstage = 2;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\tvar pact = new _Pact();\n\tvar reject = _settle.bind(null, pact, 2);\n\t(stage === 0 ? shouldContinue.then(_resumeAfterTest) : stage === 1 ? result.then(_resumeAfterBody) : updateValue.then(_resumeAfterUpdate)).then(void 0, reject);\n\treturn pact;\n\tfunction _resumeAfterBody(value) {\n\t\tresult = value;\n\t\tdo {\n\t\t\tif (update) {\n\t\t\t\tupdateValue = update();\n\t\t\t\tif (updateValue && updateValue.then && !_isSettledPact(updateValue)) {\n\t\t\t\t\tupdateValue.then(_resumeAfterUpdate).then(void 0, reject);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t\tshouldContinue = test();\n\t\t\tif (!shouldContinue || (_isSettledPact(shouldContinue) && !shouldContinue.v)) {\n\t\t\t\t_settle(pact, 1, result);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tif (shouldContinue.then) {\n\t\t\t\tshouldContinue.then(_resumeAfterTest).then(void 0, reject);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tresult = body();\n\t\t\tif (_isSettledPact(result)) {\n\t\t\t\tresult = result.v;\n\t\t\t}\n\t\t} while (!result || !result.then);\n\t\tresult.then(_resumeAfterBody).then(void 0, reject);\n\t}\n\tfunction _resumeAfterTest(shouldContinue) {\n\t\tif (shouldContinue) {\n\t\t\tresult = body();\n\t\t\tif (result && result.then) {\n\t\t\t\tresult.then(_resumeAfterBody).then(void 0, reject);\n\t\t\t} else {\n\t\t\t\t_resumeAfterBody(result);\n\t\t\t}\n\t\t} else {\n\t\t\t_settle(pact, 1, result);\n\t\t}\n\t}\n\tfunction _resumeAfterUpdate() {\n\t\tif (shouldContinue = test()) {\n\t\t\tif (shouldContinue.then) {\n\t\t\t\tshouldContinue.then(_resumeAfterTest).then(void 0, reject);\n\t\t\t} else {\n\t\t\t\t_resumeAfterTest(shouldContinue);\n\t\t\t}\n\t\t} else {\n\t\t\t_settle(pact, 1, result);\n\t\t}\n\t}\n}\n\n// Asynchronously implement a do ... while loop\nexport function _do(body, test) {\n\tvar awaitBody;\n\tdo {\n\t\tvar result = body();\n\t\tif (result && result.then) {\n\t\t\tif (_isSettledPact(result)) {\n\t\t\t\tresult = result.v;\n\t\t\t} else {\n\t\t\t\tawaitBody = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tvar shouldContinue = test();\n\t\tif (_isSettledPact(shouldContinue)) {\n\t\t\tshouldContinue = shouldContinue.v;\n\t\t}\n\t\tif (!shouldContinue) {\n\t\t\treturn result;\n\t\t}\n\t} while (!shouldContinue.then);\n\tconst pact = new _Pact();\n\tconst reject = _settle.bind(null, pact, 2);\n\t(awaitBody ? result.then(_resumeAfterBody) : shouldContinue.then(_resumeAfterTest)).then(void 0, reject);\n\treturn pact;\n\tfunction _resumeAfterBody(value) {\n\t\tresult = value;\n\t\tfor (;;) {\n\t\t\tshouldContinue = test();\n\t\t\tif (_isSettledPact(shouldContinue)) {\n\t\t\t\tshouldContinue = shouldContinue.v;\n\t\t\t}\n\t\t\tif (!shouldContinue) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (shouldContinue.then) {\n\t\t\t\tshouldContinue.then(_resumeAfterTest).then(void 0, reject);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tresult = body();\n\t\t\tif (result && result.then) {\n\t\t\t\tif (_isSettledPact(result)) {\n\t\t\t\t\tresult = result.v;\n\t\t\t\t} else {\n\t\t\t\t\tresult.then(_resumeAfterBody).then(void 0, reject);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t_settle(pact, 1, result);\n\t}\n\tfunction _resumeAfterTest(shouldContinue) {\n\t\tif (shouldContinue) {\n\t\t\tdo {\n\t\t\t\tresult = body();\n\t\t\t\tif (result && result.then) {\n\t\t\t\t\tif (_isSettledPact(result)) {\n\t\t\t\t\t\tresult = result.v;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tresult.then(_resumeAfterBody).then(void 0, reject);\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tshouldContinue = test();\n\t\t\t\tif (_isSettledPact(shouldContinue)) {\n\t\t\t\t\tshouldContinue = shouldContinue.v;\n\t\t\t\t}\n\t\t\t\tif (!shouldContinue) {\n\t\t\t\t\t_settle(pact, 1, result);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t} while (!shouldContinue.then);\n\t\t\tshouldContinue.then(_resumeAfterTest).then(void 0, reject);\n\t\t} else {\n\t\t\t_settle(pact, 1, result);\n\t\t}\n\t}\n}\n\n// Asynchronously implement a switch statement\nexport function _switch(discriminant, cases) {\n\tvar dispatchIndex = -1;\n\tvar awaitBody;\n\touter: {\n\t\tfor (var i = 0; i < cases.length; i++) {\n\t\t\tvar test = cases[i][0];\n\t\t\tif (test) {\n\t\t\t\tvar testValue = test();\n\t\t\t\tif (testValue && testValue.then) {\n\t\t\t\t\tbreak outer;\n\t\t\t\t}\n\t\t\t\tif (testValue === discriminant) {\n\t\t\t\t\tdispatchIndex = i;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t// Found the default case, set it as the pending dispatch case\n\t\t\t\tdispatchIndex = i;\n\t\t\t}\n\t\t}\n\t\tif (dispatchIndex !== -1) {\n\t\t\tdo {\n\t\t\t\tvar body = cases[dispatchIndex][1];\n\t\t\t\twhile (!body) {\n\t\t\t\t\tdispatchIndex++;\n\t\t\t\t\tbody = cases[dispatchIndex][1];\n\t\t\t\t}\n\t\t\t\tvar result = body();\n\t\t\t\tif (result && result.then) {\n\t\t\t\t\tawaitBody = true;\n\t\t\t\t\tbreak outer;\n\t\t\t\t}\n\t\t\t\tvar fallthroughCheck = cases[dispatchIndex][2];\n\t\t\t\tdispatchIndex++;\n\t\t\t} while (fallthroughCheck && !fallthroughCheck());\n\t\t\treturn result;\n\t\t}\n\t}\n\tconst pact = new _Pact();\n\tconst reject = _settle.bind(null, pact, 2);\n\t(awaitBody ? result.then(_resumeAfterBody) : testValue.then(_resumeAfterTest)).then(void 0, reject);\n\treturn pact;\n\tfunction _resumeAfterTest(value) {\n\t\tfor (;;) {\n\t\t\tif (value === discriminant) {\n\t\t\t\tdispatchIndex = i;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (++i === cases.length) {\n\t\t\t\tif (dispatchIndex !== -1) {\n\t\t\t\t\tbreak;\n\t\t\t\t} else {\n\t\t\t\t\t_settle(pact, 1, result);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t\ttest = cases[i][0];\n\t\t\tif (test) {\n\t\t\t\tvalue = test();\n\t\t\t\tif (value && value.then) {\n\t\t\t\t\tvalue.then(_resumeAfterTest).then(void 0, reject);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tdispatchIndex = i;\n\t\t\t}\n\t\t}\n\t\tdo {\n\t\t\tvar body = cases[dispatchIndex][1];\n\t\t\twhile (!body) {\n\t\t\t\tdispatchIndex++;\n\t\t\t\tbody = cases[dispatchIndex][1];\n\t\t\t}\n\t\t\tvar result = body();\n\t\t\tif (result && result.then) {\n\t\t\t\tresult.then(_resumeAfterBody).then(void 0, reject);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tvar fallthroughCheck = cases[dispatchIndex][2];\n\t\t\tdispatchIndex++;\n\t\t} while (fallthroughCheck && !fallthroughCheck());\n\t\t_settle(pact, 1, result);\n\t}\n\tfunction _resumeAfterBody(result) {\n\t\tfor (;;) {\n\t\t\tvar fallthroughCheck = cases[dispatchIndex][2];\n\t\t\tif (!fallthroughCheck || fallthroughCheck()) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tdispatchIndex++;\n\t\t\tvar body = cases[dispatchIndex][1];\n\t\t\twhile (!body) {\n\t\t\t\tdispatchIndex++;\n\t\t\t\tbody = cases[dispatchIndex][1];\n\t\t\t}\n\t\t\tresult = body();\n\t\t\tif (result && result.then) {\n\t\t\t\tresult.then(_resumeAfterBody).then(void 0, reject);\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\t_settle(pact, 1, result);\n\t}\n}\n\n// Asynchronously call a function and pass the result to explicitly passed continuations\nexport function _call(body, then, direct) {\n\tif (direct) {\n\t\treturn then ? then(body()) : body();\n\t}\n\ttry {\n\t\tvar result = Promise.resolve(body());\n\t\treturn then ? result.then(then) : result;\n\t} catch (e) {\n\t\treturn Promise.reject(e);\n\t}\n}\n\n// Asynchronously call a function and swallow the result\nexport function _callIgnored(body, direct) {\n\treturn _call(body, _empty, direct);\n}\n\n// Asynchronously call a function and pass the result to explicitly passed continuations\nexport function _invoke(body, then) {\n\tvar result = body();\n\tif (result && result.then) {\n\t\treturn result.then(then);\n\t}\n\treturn then(result);\n}\n\n// Asynchronously call a function and swallow the result\nexport function _invokeIgnored(body) {\n\tvar result = body();\n\tif (result && result.then) {\n\t\treturn result.then(_empty);\n\t}\n}\n\n// Asynchronously call a function and send errors to recovery continuation\nexport function _catch(body, recover) {\n\ttry {\n\t\tvar result = body();\n\t} catch(e) {\n\t\treturn recover(e);\n\t}\n\tif (result && result.then) {\n\t\treturn result.then(void 0, recover);\n\t}\n\treturn result;\n}\n\n// Asynchronously await a promise and pass the result to a finally continuation\nexport function _finallyRethrows(body, finalizer) {\n\ttry {\n\t\tvar result = body();\n\t} catch (e) {\n\t\treturn finalizer(true, e);\n\t}\n\tif (result && result.then) {\n\t\treturn result.then(finalizer.bind(null, false), finalizer.bind(null, true));\n\t}\n\treturn finalizer(false, result);\n}\n\n// Asynchronously await a promise and invoke a finally continuation that always overrides the result\nexport function _finally(body, finalizer) {\n\ttry {\n\t\tvar result = body();\n\t} catch (e) {\n\t\treturn finalizer();\n\t}\n\tif (result && result.then) {\n\t\treturn result.then(finalizer, finalizer);\n\t}\n\treturn finalizer();\n}\n\n// Rethrow or return a value from a finally continuation\nexport function _rethrow(thrown, value) {\n\tif (thrown)\n\t\tthrow value;\n\treturn value;\n}\n\n// Empty function to implement break and other control flow that ignores asynchronous results\nexport function _empty() {\n}\n\n// Sentinel value for early returns in generators \nexport const _earlyReturn = /*#__PURE__*/ {};\n\n// Asynchronously call a function and send errors to recovery continuation, skipping early returns\nexport function _catchInGenerator(body, recover) {\n\treturn _catch(body, function(e) {\n\t\tif (e === _earlyReturn) {\n\t\t\tthrow e;\n\t\t}\n\t\treturn recover(e);\n\t});\n}\n\n// Asynchronous generator class; accepts the entrypoint of the generator, to which it passes itself when the generator should start\nexport const _AsyncGenerator = /*#__PURE__*/(function() {\n\tfunction _AsyncGenerator(entry) {\n\t\tthis._entry = entry;\n\t\tthis._pact = null;\n\t\tthis._resolve = null;\n\t\tthis._return = null;\n\t\tthis._promise = null;\n\t}\n\n\tfunction _wrapReturnedValue(value) {\n\t\treturn { value: value, done: true };\n\t}\n\tfunction _wrapYieldedValue(value) {\n\t\treturn { value: value, done: false };\n\t}\n\n\t_AsyncGenerator.prototype._yield = function(value) {\n\t\t// Yield the value to the pending next call\n\t\tthis._resolve(value && value.then ? value.then(_wrapYieldedValue) : _wrapYieldedValue(value));\n\t\t// Return a pact for an upcoming next/return/throw call\n\t\treturn this._pact = new _Pact();\n\t};\n\t_AsyncGenerator.prototype.next = function(value) {\n\t\t// Advance the generator, starting it if it has yet to be started\n\t\tconst _this = this;\n\t\treturn _this._promise = new Promise(function (resolve) {\n\t\t\tconst _pact = _this._pact;\n\t\t\tif (_pact === null) {\n\t\t\t\tconst _entry = _this._entry;\n\t\t\t\tif (_entry === null) {\n\t\t\t\t\t// Generator is started, but not awaiting a yield expression\n\t\t\t\t\t// Abandon the next call!\n\t\t\t\t\treturn resolve(_this._promise);\n\t\t\t\t}\n\t\t\t\t// Start the generator\n\t\t\t\t_this._entry = null;\n\t\t\t\t_this._resolve = resolve;\n\t\t\t\tfunction returnValue(value) {\n\t\t\t\t\t_this._resolve(value && value.then ? value.then(_wrapReturnedValue) : _wrapReturnedValue(value));\n\t\t\t\t\t_this._pact = null;\n\t\t\t\t\t_this._resolve = null;\n\t\t\t\t}\n\t\t\t\tvar result = _entry(_this);\n\t\t\t\tif (result && result.then) {\n\t\t\t\t\tresult.then(returnValue, function(error) {\n\t\t\t\t\t\tif (error === _earlyReturn) {\n\t\t\t\t\t\t\treturnValue(_this._return);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tconst pact = new _Pact();\n\t\t\t\t\t\t\t_this._resolve(pact);\n\t\t\t\t\t\t\t_this._pact = null;\n\t\t\t\t\t\t\t_this._resolve = null;\n\t\t\t\t\t\t\t_resolve(pact, 2, error);\n\t\t\t\t\t\t}\n\t\t\t\t\t});\n\t\t\t\t} else {\n\t\t\t\t\treturnValue(result);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t// Generator is started and a yield expression is pending, settle it\n\t\t\t\t_this._pact = null;\n\t\t\t\t_this._resolve = resolve;\n\t\t\t\t_settle(_pact, 1, value);\n\t\t\t}\n\t\t});\n\t};\n\t_AsyncGenerator.prototype.return = function(value) {\n\t\t// Early return from the generator if started, otherwise abandons the generator\n\t\tconst _this = this;\n\t\treturn _this._promise = new Promise(function (resolve) {\n\t\t\tconst _pact = _this._pact;\n\t\t\tif (_pact === null) {\n\t\t\t\tif (_this._entry === null) {\n\t\t\t\t\t// Generator is started, but not awaiting a yield expression\n\t\t\t\t\t// Abandon the return call!\n\t\t\t\t\treturn resolve(_this._promise);\n\t\t\t\t}\n\t\t\t\t// Generator is not started, abandon it and return the specified value\n\t\t\t\t_this._entry = null;\n\t\t\t\treturn resolve(value && value.then ? value.then(_wrapReturnedValue) : _wrapReturnedValue(value));\n\t\t\t}\n\t\t\t// Settle the yield expression with a rejected \"early return\" value\n\t\t\t_this._return = value;\n\t\t\t_this._resolve = resolve;\n\t\t\t_this._pact = null;\n\t\t\t_settle(_pact, 2, _earlyReturn);\n\t\t});\n\t};\n\t_AsyncGenerator.prototype.throw = function(error) {\n\t\t// Inject an exception into the pending yield expression\n\t\tconst _this = this;\n\t\treturn _this._promise = new Promise(function (resolve, reject) {\n\t\t\tconst _pact = _this._pact;\n\t\t\tif (_pact === null) {\n\t\t\t\tif (_this._entry === null) {\n\t\t\t\t\t// Generator is started, but not awaiting a yield expression\n\t\t\t\t\t// Abandon the throw call!\n\t\t\t\t\treturn resolve(_this._promise);\n\t\t\t\t}\n\t\t\t\t// Generator is not started, abandon it and return a rejected Promise containing the error\n\t\t\t\t_this._entry = null;\n\t\t\t\treturn reject(error);\n\t\t\t}\n\t\t\t// Settle the yield expression with the value as a rejection\n\t\t\t_this._resolve = resolve;\n\t\t\t_this._pact = null;\n\t\t\t_settle(_pact, 2, error);\n\t\t});\n\t};\n\n\t_AsyncGenerator.prototype[_asyncIteratorSymbol] = function() {\n\t\treturn this;\n\t};\n\t\n\treturn _AsyncGenerator;\n})();\n","import {\n  LocalParticipant,\n  LocalTrack,\n  Participant,\n  ParticipantEvent,\n  Track,\n  TrackPublication,\n} from \"livekit-client\";\nimport { useEffect, useState } from \"react\";\n\nexport interface ParticipantState {\n  isSpeaking: boolean;\n  isLocal: boolean;\n  isMuted: boolean;\n  metadata?: string;\n  publications: TrackPublication[];\n  subscribedTracks: TrackPublication[];\n  unpublishTrack: (track: LocalTrack) => void;\n}\n\nexport function useParticipant(participant: Participant): ParticipantState {\n  const [isMuted, setMuted] = useState(false);\n  const [isSpeaking, setSpeaking] = useState(false);\n  const [metadata, setMetadata] = useState<string>();\n  const [publications, setPublications] = useState<TrackPublication[]>([]);\n  const [subscribedTracks, setSubscribedTracks] = useState<TrackPublication[]>(\n    []\n  );\n\n  const onPublicationsChanged = () => {\n    setPublications(Array.from(participant.tracks.values()));\n    setSubscribedTracks(\n      Array.from(participant.tracks.values()).filter((pub) => {\n        return pub.track !== undefined;\n      })\n    );\n  };\n  const unpublishTrack = async (track: LocalTrack) => {\n    if (!(participant instanceof LocalParticipant)) {\n      throw new Error(\"could not unpublish, not a local participant\");\n    }\n    (participant as LocalParticipant).unpublishTrack(track);\n    participant.emit(\"localtrackchanged\");\n  };\n\n  useEffect(() => {\n    const onMuted = (pub: TrackPublication) => {\n      if (pub.kind === Track.Kind.Audio) {\n        setMuted(true);\n      }\n    };\n    const onUnmuted = (pub: TrackPublication) => {\n      if (pub.kind === Track.Kind.Audio) {\n        setMuted(false);\n      }\n    };\n    const onMetadataChanged = () => {\n      if (participant.metadata) {\n        setMetadata(participant.metadata);\n      }\n    };\n    const onIsSpeakingChanged = () => {\n      setSpeaking(participant.isSpeaking);\n    };\n\n    // register listeners\n    participant.on(ParticipantEvent.TrackMuted, onMuted);\n    participant.on(ParticipantEvent.TrackUnmuted, onUnmuted);\n    participant.on(ParticipantEvent.MetadataChanged, onMetadataChanged);\n    participant.on(ParticipantEvent.IsSpeakingChanged, onIsSpeakingChanged);\n    participant.on(ParticipantEvent.TrackPublished, onPublicationsChanged);\n    participant.on(ParticipantEvent.TrackUnpublished, onPublicationsChanged);\n    participant.on(ParticipantEvent.TrackSubscribed, onPublicationsChanged);\n    participant.on(ParticipantEvent.TrackUnsubscribed, onPublicationsChanged);\n    participant.on(\"localtrackchanged\", onPublicationsChanged);\n\n    // set initial state\n    onMetadataChanged();\n    onIsSpeakingChanged();\n    onPublicationsChanged();\n\n    return () => {\n      // cleanup\n      participant.off(ParticipantEvent.TrackMuted, onMuted);\n      participant.off(ParticipantEvent.TrackUnmuted, onUnmuted);\n      participant.off(ParticipantEvent.MetadataChanged, onMetadataChanged);\n      participant.off(ParticipantEvent.IsSpeakingChanged, onIsSpeakingChanged);\n      participant.off(ParticipantEvent.TrackPublished, onPublicationsChanged);\n      participant.off(ParticipantEvent.TrackUnpublished, onPublicationsChanged);\n      participant.off(ParticipantEvent.TrackSubscribed, onPublicationsChanged);\n      participant.off(\n        ParticipantEvent.TrackUnsubscribed,\n        onPublicationsChanged\n      );\n      participant.off(\"localtrackchanged\", onPublicationsChanged);\n    };\n  }, [participant]);\n\n  let muted: boolean | undefined;\n  participant.audioTracks.forEach((pub) => {\n    muted = pub.isMuted;\n  });\n  if (muted === undefined) {\n    muted = true;\n  }\n  if (isMuted !== muted) {\n    setMuted(muted);\n  }\n\n  return {\n    isLocal: participant instanceof LocalParticipant,\n    isSpeaking,\n    isMuted,\n    publications,\n    subscribedTracks,\n    metadata,\n    unpublishTrack,\n  };\n}\n","import {\n  faDesktop,\n  faMicrophone,\n  faMicrophoneSlash,\n  faStop,\n  faVideo,\n  faVideoSlash,\n} from \"@fortawesome/free-solid-svg-icons\";\nimport {\n  createLocalAudioTrack,\n  createLocalVideoTrack,\n  LocalTrackPublication,\n  LocalVideoTrack,\n  Room,\n  Track,\n  VideoPresets,\n} from \"livekit-client\";\nimport React, { ReactElement } from \"react\";\nimport { useParticipant } from \"../useParticipant\";\nimport { ControlButton } from \"./ControlButton\";\nimport styles from \"./styles.module.css\";\n\nexport interface ControlsProps {\n  room: Room;\n  enableScreenShare?: boolean;\n  enableAudio?: boolean;\n  enableVideo?: boolean;\n  onLeave?: (room: Room) => void;\n}\n\nexport const ControlsView = ({\n  room,\n  enableScreenShare,\n  enableAudio,\n  enableVideo,\n  onLeave,\n}: ControlsProps) => {\n  const { publications, isMuted, unpublishTrack } = useParticipant(\n    room.localParticipant\n  );\n\n  const audioPub = publications.find((val) => val.kind === Track.Kind.Audio);\n  const videoPub = publications.find((val) => {\n    return val.kind === Track.Kind.Video && val.trackName !== \"screen\";\n  });\n  const screenPub = publications.find((val) => {\n    return val.kind === Track.Kind.Video && val.trackName === \"screen\";\n  });\n  if (enableScreenShare === undefined) {\n    enableScreenShare = true;\n  }\n  if (enableVideo === undefined) {\n    enableVideo = true;\n  }\n  if (enableAudio === undefined) {\n    enableAudio = true;\n  }\n\n  let muteButton: ReactElement | undefined;\n  if (enableAudio) {\n    if (!audioPub || isMuted) {\n      muteButton = (\n        <ControlButton\n          label=\"Unmute\"\n          icon={faMicrophoneSlash}\n          onClick={async () => {\n            if (audioPub) {\n              (audioPub as LocalTrackPublication).unmute();\n            } else {\n              // track not published\n              const audioTrack = await createLocalAudioTrack();\n              room.localParticipant.publishTrack(audioTrack);\n            }\n          }}\n        />\n      );\n    } else {\n      muteButton = (\n        <ControlButton\n          label=\"Mute\"\n          icon={faMicrophone}\n          onClick={() => (audioPub as LocalTrackPublication).mute()}\n        />\n      );\n    }\n  }\n\n  let videoButton: ReactElement | undefined;\n  if (enableVideo) {\n    if (videoPub?.track) {\n      videoButton = (\n        <ControlButton\n          label=\"Stop video\"\n          icon={faVideo}\n          onClick={() => unpublishTrack(videoPub.track as LocalVideoTrack)}\n        />\n      );\n    } else {\n      videoButton = (\n        <ControlButton\n          label=\"Start video\"\n          icon={faVideoSlash}\n          onClick={async () => {\n            const videoTrack = await createLocalVideoTrack();\n            room.localParticipant.publishTrack(videoTrack);\n          }}\n        />\n      );\n    }\n  }\n\n  let screenButton: ReactElement | undefined;\n  if (enableScreenShare) {\n    if (screenPub?.track) {\n      screenButton = (\n        <ControlButton\n          label=\"Stop sharing\"\n          icon={faStop}\n          onClick={() => unpublishTrack(screenPub.track as LocalVideoTrack)}\n        />\n      );\n    } else {\n      screenButton = (\n        <ControlButton\n          label=\"Share screen\"\n          icon={faDesktop}\n          onClick={async () => {\n            try {\n              const captureStream =\n                // @ts-ignore\n                (await navigator.mediaDevices.getDisplayMedia({\n                  video: {\n                    width: VideoPresets.fhd.resolution.width,\n                    height: VideoPresets.fhd.resolution.height,\n                  },\n                })) as MediaStream;\n\n              room.localParticipant.publishTrack(captureStream.getTracks()[0], {\n                name: \"screen\",\n                videoEncoding: {\n                  maxBitrate: 3000000,\n                  maxFramerate: 30,\n                },\n              });\n            } catch (err) {\n              // TODO: display error\n            }\n          }}\n        />\n      );\n    }\n  }\n\n  return (\n    <div className={styles.controlsWrapper}>\n      {muteButton}\n      {videoButton}\n      {screenButton}\n      {onLeave && (\n        <ControlButton\n          label=\"End\"\n          className={styles.dangerButton}\n          onClick={() => {\n            room.disconnect();\n            onLeave(room);\n          }}\n        />\n      )}\n    </div>\n  );\n};\n","import { Property } from \"csstype\";\nimport { Track } from \"livekit-client\";\nimport React, { CSSProperties, useEffect, useRef } from \"react\";\nimport styles from \"./styles.module.css\";\n\nexport interface VideoRendererProps {\n  track: Track;\n  isLocal: boolean;\n  objectFit?: Property.ObjectFit;\n  className?: string;\n  width?: Property.Width;\n  height?: Property.Height;\n}\n\nexport const VideoRenderer = ({\n  track,\n  isLocal,\n  objectFit,\n  className,\n  width,\n  height,\n}: VideoRendererProps) => {\n  const ref = useRef<HTMLVideoElement>(null);\n\n  useEffect(() => {\n    const el = ref.current;\n    if (!el) {\n      return;\n    }\n    el.muted = true;\n    track.attach(el);\n    return () => {\n      track.detach(el);\n    };\n  }, [track, ref]);\n\n  const isFrontFacing =\n    track.mediaStreamTrack?.getSettings().facingMode !== \"environment\";\n  const style: CSSProperties = {\n    transform: isLocal && isFrontFacing ? \"rotateY(180deg)\" : \"\",\n    width: width,\n    height: height,\n  };\n  if (objectFit) {\n    style.objectFit = objectFit;\n  }\n\n  // TODO: could use react native RCTVideoView\n\n  return (\n    <video ref={ref} className={className ?? styles.video} style={style} />\n  );\n};\n","import {\n  faMicrophone,\n  faMicrophoneSlash,\n} from \"@fortawesome/free-solid-svg-icons\";\nimport { FontAwesomeIcon } from \"@fortawesome/react-fontawesome\";\nimport { Property } from \"csstype\";\nimport {\n  Participant,\n  RemoteTrackPublication,\n  Track,\n  TrackPublication,\n} from \"livekit-client\";\nimport { VideoQuality } from \"livekit-client/dist/proto/livekit_rtc\";\nimport React, { CSSProperties, ReactElement, useEffect, useState } from \"react\";\nimport AspectRatio from \"react-aspect-ratio\";\nimport { useInView } from \"react-intersection-observer\";\nimport { useParticipant } from \"../useParticipant\";\nimport styles from \"./styles.module.css\";\nimport { VideoRenderer } from \"./VideoRenderer\";\n\nexport interface ParticipantProps {\n  participant: Participant;\n  displayName?: string;\n  // width in CSS\n  width?: Property.Width;\n  // height in CSS\n  height?: Property.Height;\n  className?: string;\n  // aspect ratio width, if set, maintains aspect ratio\n  aspectWidth?: number;\n  // aspect ratio height\n  aspectHeight?: number;\n  showOverlay?: boolean;\n  quality?: VideoQuality;\n  // when set, video will be disabled when not in view\n  adaptiveVideo?: Boolean;\n  onMouseEnter?: () => void;\n  onMouseLeave?: () => void;\n  onClick?: () => void;\n}\n\nexport const ParticipantView = ({\n  participant,\n  width,\n  height,\n  className,\n  aspectWidth,\n  aspectHeight,\n  displayName,\n  showOverlay,\n  quality,\n  adaptiveVideo,\n  onMouseEnter,\n  onMouseLeave,\n  onClick,\n}: ParticipantProps) => {\n  const { isLocal, isMuted, subscribedTracks } = useParticipant(participant);\n  const { ref, inView } = useInView();\n  const [videoPub, setVideoPub] = useState<TrackPublication>();\n  const [videoEnabled, setVideoEnabled] = useState(true);\n  const [callbackTimeout, setCallbackTimeout] =\n    useState<ReturnType<typeof setTimeout>>();\n\n  // when video is hidden, disable it to optimize for bandwidth\n  useEffect(() => {\n    if (!ref) {\n      return;\n    }\n    let enabled = inView;\n    if (!adaptiveVideo) {\n      enabled = true;\n    }\n    if (videoEnabled !== enabled) {\n      setVideoEnabled(enabled);\n    }\n  }, [ref, participant, inView, adaptiveVideo]);\n\n  // effect to set videoPub\n  useEffect(() => {\n    let newVideoPub: TrackPublication | undefined;\n    subscribedTracks.forEach((pub) => {\n      if (\n        pub.isSubscribed &&\n        pub.kind === Track.Kind.Video &&\n        pub.trackName !== \"screen\" &&\n        !newVideoPub\n      ) {\n        newVideoPub = pub;\n      }\n    });\n    setVideoPub(newVideoPub);\n  }, [subscribedTracks]);\n\n  // debounce adaptive settings, to ensure less twitchy responses\n  useEffect(() => {\n    if (callbackTimeout) {\n      clearTimeout(callbackTimeout);\n      setCallbackTimeout(undefined);\n    }\n    if (!(videoPub instanceof RemoteTrackPublication)) {\n      return;\n    }\n\n    // always enable right away, while disable quality changes are delayed\n    if (videoEnabled) {\n      videoPub.setEnabled(true);\n    }\n\n    setCallbackTimeout(\n      setTimeout(() => {\n        videoPub.setEnabled(videoEnabled);\n        if (videoEnabled) {\n          videoPub.setVideoQuality(quality ?? VideoQuality.HIGH);\n        }\n      }, 3000)\n    );\n    return () => {\n      if (callbackTimeout) {\n        clearTimeout(callbackTimeout);\n        setCallbackTimeout(undefined);\n      }\n    };\n  }, [quality, videoEnabled, videoPub]);\n\n  const containerStyles: CSSProperties = {\n    width: width,\n    height: height,\n  };\n\n  // when aspect matches, cover instead\n  let objectFit: Property.ObjectFit = \"contain\";\n  if (\n    aspectWidth &&\n    aspectHeight &&\n    videoPub?.dimensions &&\n    (aspectWidth - aspectHeight) *\n      (videoPub.dimensions.width - videoPub.dimensions.height) >\n      0\n  ) {\n    objectFit = \"cover\";\n  }\n\n  if (!displayName) {\n    displayName = participant.identity;\n    if (isLocal) {\n      displayName += \" (You)\";\n    }\n  }\n\n  let mainElement: ReactElement;\n  if (videoPub?.track) {\n    mainElement = (\n      <VideoRenderer\n        track={videoPub.track}\n        isLocal={isLocal}\n        objectFit={objectFit}\n        width=\"100%\"\n        height=\"100%\"\n      />\n    );\n  } else {\n    mainElement = <div className={styles.placeholder} />;\n  }\n\n  const classes = [styles.participant];\n  if (className) {\n    classes.push(className);\n  }\n\n  return (\n    <div\n      ref={ref}\n      className={classes.join(\" \")}\n      style={containerStyles}\n      onMouseEnter={onMouseEnter}\n      onMouseLeave={onMouseLeave}\n      onClick={onClick}\n    >\n      {aspectWidth && aspectHeight && (\n        <AspectRatio ratio={aspectWidth / aspectHeight}>\n          {mainElement}\n        </AspectRatio>\n      )}\n      {(!aspectWidth || !aspectHeight) && mainElement}\n\n      {showOverlay && (\n        <div className={styles.participantBar}>\n          <div>{displayName}</div>\n          <div>\n            <FontAwesomeIcon\n              icon={isMuted ? faMicrophoneSlash : faMicrophone}\n              height={24}\n              className={isMuted ? styles.iconRed : styles.iconNormal}\n            />\n          </div>\n        </div>\n      )}\n    </div>\n  );\n};\n","import { Property } from \"csstype\";\nimport { Track } from \"livekit-client\";\nimport React from \"react\";\nimport styles from \"./styles.module.css\";\nimport { VideoRenderer } from \"./VideoRenderer\";\n\ninterface ScreenShareProps {\n  track: Track;\n  width?: Property.Width;\n  height?: Property.Height;\n}\n\nexport const ScreenShareView = ({ track, width, height }: ScreenShareProps) => {\n  return (\n    <div className={styles.screenShare}>\n      <VideoRenderer\n        track={track}\n        isLocal={false}\n        width={width}\n        height={height}\n      />\n    </div>\n  );\n};\n","import {\n  LocalParticipant,\n  Participant,\n  RemoteVideoTrack,\n} from \"livekit-client\";\nimport { VideoQuality } from \"livekit-client/dist/proto/livekit_rtc\";\nimport React, { ReactElement, useState } from \"react\";\nimport { ControlsView } from \"../ControlsView\";\nimport { ParticipantView } from \"../ParticipantView\";\nimport { ScreenShareView } from \"../ScreenShareView\";\nimport { StageProps } from \"../StageProps\";\nimport styles from \"./styles.module.css\";\n\nexport const DesktopStage = ({\n  roomState,\n  participantRenderer,\n  controlRenderer,\n  onLeave,\n  adaptiveVideo,\n}: StageProps) => {\n  const { isConnecting, error, participants, room } = roomState;\n  const [showOverlay, setShowOverlay] = useState(false);\n\n  if (error) {\n    return <div>error {error.message}</div>;\n  }\n\n  if (isConnecting) {\n    return <div>connecting</div>;\n  }\n  if (!room) {\n    return <div>room closed</div>;\n  }\n\n  if (participants.length === 0) {\n    return <div>no one is in the room</div>;\n  }\n\n  const ParticipantRenderer = participantRenderer ?? ParticipantView;\n  const ControlRenderer = controlRenderer ?? ControlsView;\n\n  // find first participant with screen shared\n  let screenTrack: RemoteVideoTrack | undefined;\n  participants.forEach((p) => {\n    if (p instanceof LocalParticipant) {\n      return;\n    }\n    p.videoTracks.forEach((track) => {\n      if (track.trackName === \"screen\" && track.track) {\n        screenTrack = track.track as RemoteVideoTrack;\n      }\n    });\n  });\n\n  let otherParticipants: Participant[];\n  let mainView: ReactElement;\n  if (screenTrack) {\n    otherParticipants = participants;\n    mainView = (\n      <ScreenShareView track={screenTrack} height=\"100%\" width=\"100%\" />\n    );\n  } else {\n    otherParticipants = participants.slice(1);\n    mainView = (\n      <ParticipantRenderer\n        key={participants[0].identity}\n        participant={participants[0]}\n        showOverlay={showOverlay}\n        quality={VideoQuality.HIGH}\n        onMouseEnter={() => setShowOverlay(true)}\n        onMouseLeave={() => setShowOverlay(false)}\n      />\n    );\n  }\n\n  return (\n    // global container\n    <div className={styles.container}>\n      <div className={styles.stage}>\n        <div className={styles.stageCenter}>{mainView}</div>\n        <div className={styles.sidebar}>\n          {otherParticipants.map((participant, i) => {\n            let quality = VideoQuality.HIGH;\n            if (adaptiveVideo && i > 4) {\n              quality = VideoQuality.LOW;\n            }\n            return (\n              <ParticipantRenderer\n                key={participant.identity}\n                participant={participant}\n                width=\"100%\"\n                aspectWidth={16}\n                aspectHeight={9}\n                showOverlay={showOverlay}\n                quality={quality}\n                onMouseEnter={() => setShowOverlay(true)}\n                onMouseLeave={() => setShowOverlay(false)}\n                adaptiveVideo={adaptiveVideo}\n              />\n            );\n          })}\n        </div>\n      </div>\n      <div className={styles.controlsArea}>\n        <ControlRenderer room={room} onLeave={onLeave} />\n      </div>\n    </div>\n  );\n};\n","import {\n  LocalParticipant,\n  Participant,\n  RemoteVideoTrack,\n} from \"livekit-client\";\nimport { VideoQuality } from \"livekit-client/dist/proto/livekit_rtc\";\nimport React, { ReactElement, useState } from \"react\";\nimport { ControlsView } from \"../ControlsView\";\nimport { ParticipantView } from \"../ParticipantView\";\nimport { ScreenShareView } from \"../ScreenShareView\";\nimport { StageProps } from \"../StageProps\";\nimport styles from \"./styles.module.css\";\n\nexport const MobileStage = ({\n  roomState,\n  participantRenderer,\n  controlRenderer,\n  onLeave,\n  adaptiveVideo,\n}: StageProps) => {\n  const { isConnecting, error, participants, room } = roomState;\n  const [showOverlay, setShowOverlay] = useState(false);\n\n  if (error) {\n    return <div>error {error.message}</div>;\n  }\n\n  if (isConnecting) {\n    return <div>connecting</div>;\n  }\n  if (!room) {\n    return <div>room closed</div>;\n  }\n\n  if (participants.length === 0) {\n    return <div>no one is in the room</div>;\n  }\n\n  const ParticipantRenderer = participantRenderer ?? ParticipantView;\n  const ControlRenderer = controlRenderer ?? ControlsView;\n\n  // find first participant with screen shared\n  let screenTrack: RemoteVideoTrack | undefined;\n  participants.forEach((p) => {\n    if (p instanceof LocalParticipant) {\n      return;\n    }\n    p.videoTracks.forEach((track) => {\n      if (track.trackName === \"screen\" && track.track) {\n        screenTrack = track.track as RemoteVideoTrack;\n      }\n    });\n  });\n\n  let otherParticipants: Participant[];\n  let mainView: ReactElement;\n  if (screenTrack) {\n    otherParticipants = participants;\n    mainView = (\n      <ScreenShareView track={screenTrack} height=\"100%\" width=\"100%\" />\n    );\n  } else {\n    otherParticipants = participants.slice(1);\n    mainView = (\n      <ParticipantRenderer\n        key={participants[0].identity}\n        participant={participants[0]}\n        showOverlay={showOverlay}\n        width=\"100%\"\n        height=\"100%\"\n        quality={VideoQuality.MEDIUM}\n        onMouseEnter={() => setShowOverlay(true)}\n        onMouseLeave={() => setShowOverlay(false)}\n        adaptiveVideo={adaptiveVideo}\n      />\n    );\n  }\n\n  return (\n    // global container\n    <div className={styles.container}>\n      <div className={styles.stage}>{mainView}</div>\n      <div className={styles.participantsArea}>\n        {otherParticipants.map((participant, i) => {\n          let quality = VideoQuality.MEDIUM;\n          if (adaptiveVideo && i > 4) {\n            quality = VideoQuality.LOW;\n          }\n          return (\n            <ParticipantRenderer\n              key={participant.identity}\n              participant={participant}\n              className={styles.participant}\n              aspectWidth={4}\n              aspectHeight={3}\n              showOverlay={showOverlay}\n              quality={quality}\n              onMouseEnter={() => setShowOverlay(true)}\n              onMouseLeave={() => setShowOverlay(false)}\n              adaptiveVideo={adaptiveVideo}\n            />\n          );\n        })}\n      </div>\n      <div className={styles.controlsArea}>\n        <ControlRenderer\n          room={room}\n          enableScreenShare={false}\n          onLeave={onLeave}\n        />\n      </div>\n    </div>\n  );\n};\n","import React, { ReactElement } from \"react\";\nimport { useMediaQuery } from \"react-responsive\";\nimport { AudioRenderer } from \"./AudioRenderer\";\nimport { DesktopStage } from \"./desktop/DesktopStage\";\nimport { MobileStage } from \"./mobile/MobileStage\";\nimport { StageProps } from \"./StageProps\";\n\nexport const StageView = (stageProps: StageProps) => {\n  const isMobile = useMediaQuery({ query: \"(max-width: 800px)\" });\n\n  let mainElement: ReactElement;\n  if (isMobile) {\n    mainElement = <MobileStage {...stageProps} />;\n  } else {\n    mainElement = <DesktopStage {...stageProps} />;\n  }\n\n  return (\n    <React.Fragment>\n      {mainElement}\n      {stageProps.roomState.audioTracks.map((track) => (\n        <AudioRenderer key={track.sid} track={track} isLocal={false} />\n      ))}\n    </React.Fragment>\n  );\n};\n","import { faVideo, faVideoSlash } from \"@fortawesome/free-solid-svg-icons\";\nimport React, { useEffect, useState } from \"react\";\nimport { ControlButton, MenuItem } from \"./ControlButton\";\n\nexport interface VideoSelectButtonProps {\n  isEnabled: boolean;\n  onClick?: () => void;\n  onSourceSelected?: (device: MediaDeviceInfo) => void;\n}\n\nexport const VideoSelectButton = ({\n  isEnabled,\n  onClick,\n  onSourceSelected,\n}: VideoSelectButtonProps) => {\n  const [sources, setSources] = useState<MediaDeviceInfo[]>([]);\n  const [menuItems, setMenuItems] = useState<MenuItem[]>([]);\n\n  useEffect(() => {\n    navigator.mediaDevices.enumerateDevices().then((devices) => {\n      const videoDevices = devices.filter(\n        (item) => item.kind === \"videoinput\" && item.deviceId\n      );\n      setSources(videoDevices);\n      setMenuItems(\n        videoDevices.map((item) => {\n          return { label: item.label };\n        })\n      );\n    });\n  }, [isEnabled]);\n\n  const handleMenuItem = (item: MenuItem) => {\n    const device = sources.find((d) => d.label === item.label);\n    if (device && onSourceSelected) {\n      onSourceSelected(device);\n    }\n  };\n\n  return (\n    <ControlButton\n      label={isEnabled ? \"Disable Video\" : \"Enable Video\"}\n      icon={isEnabled ? faVideo : faVideoSlash}\n      onClick={onClick}\n      menuItems={menuItems}\n      onMenuItemClick={handleMenuItem}\n    />\n  );\n};\n","import {\n  AudioTrack,\n  connect,\n  ConnectOptions,\n  LocalParticipant,\n  Participant,\n  RemoteTrack,\n  Room,\n  RoomEvent,\n  Track,\n} from \"livekit-client\";\nimport { useCallback, useState } from \"react\";\n\nexport interface RoomState {\n  connect: (\n    url: string,\n    token: string,\n    options?: ConnectOptions\n  ) => Promise<Room | undefined>;\n  isConnecting: boolean;\n  room?: Room;\n  /* all participants in the room, including the local participant. */\n  participants: Participant[];\n  /* all subscribed audio tracks in the room, not including local participant. */\n  audioTracks: AudioTrack[];\n  error?: Error;\n}\n\nexport interface RoomOptions {\n  sortParticipants?: (participants: Participant[]) => void;\n}\n\nexport function useRoom(options?: RoomOptions): RoomState {\n  const [room, setRoom] = useState<Room>();\n  const [isConnecting, setIsConnecting] = useState(false);\n  const [error, setError] = useState<Error>();\n  const [participants, setParticipants] = useState<Participant[]>([]);\n  const [audioTracks, setAudioTracks] = useState<AudioTrack[]>([]);\n\n  const sortFunc = options?.sortParticipants ?? sortParticipants;\n\n  const connectFn = useCallback(\n    async (url: string, token: string, options?: ConnectOptions) => {\n      setIsConnecting(true);\n      try {\n        const newRoom = await connect(url, token, options);\n        setRoom(newRoom);\n        const onParticipantsChanged = () => {\n          const remotes = Array.from(newRoom.participants.values());\n          const participants: Participant[] = [newRoom.localParticipant];\n          participants.push(...remotes);\n          sortFunc(participants, newRoom.localParticipant);\n          setParticipants(participants);\n        };\n        const onSubscribedTrackChanged = (track?: RemoteTrack) => {\n          // ordering may have changed, re-sort\n          onParticipantsChanged();\n          if (track && track.kind !== Track.Kind.Audio) {\n            return;\n          }\n          const tracks: AudioTrack[] = [];\n          newRoom.participants.forEach((p) => {\n            p.audioTracks.forEach((pub) => {\n              if (pub.track && pub.kind === Track.Kind.Audio) {\n                tracks.push(pub.track);\n              }\n            });\n          });\n          setAudioTracks(tracks);\n        };\n\n        newRoom.once(RoomEvent.Disconnected, () => {\n          setTimeout(() => setRoom(undefined));\n\n          newRoom.off(RoomEvent.ParticipantConnected, onParticipantsChanged);\n          newRoom.off(RoomEvent.ParticipantDisconnected, onParticipantsChanged);\n          newRoom.off(RoomEvent.ActiveSpeakersChanged, onParticipantsChanged);\n          newRoom.off(RoomEvent.TrackSubscribed, onSubscribedTrackChanged);\n          newRoom.off(RoomEvent.TrackUnsubscribed, onSubscribedTrackChanged);\n        });\n        newRoom.on(RoomEvent.ParticipantConnected, onParticipantsChanged);\n        newRoom.on(RoomEvent.ParticipantDisconnected, onParticipantsChanged);\n        newRoom.on(RoomEvent.ActiveSpeakersChanged, onParticipantsChanged);\n        newRoom.on(RoomEvent.TrackSubscribed, onSubscribedTrackChanged);\n        newRoom.on(RoomEvent.TrackUnsubscribed, onSubscribedTrackChanged);\n\n        setIsConnecting(false);\n        onSubscribedTrackChanged();\n\n        return newRoom;\n      } catch (error) {\n        setIsConnecting(false);\n        setError(error);\n\n        return undefined;\n      }\n    },\n    []\n  );\n\n  return {\n    connect: connectFn,\n    isConnecting,\n    room,\n    error,\n    participants,\n    audioTracks,\n  };\n}\n\n/**\n * Default sort for participants, it'll order participants by:\n * 1. dominant speaker (speaker with the loudest audio level)\n * 2. local participant\n * 3. other speakers that are recently active\n * 4. participants with video on\n * 5. by joinedAt\n */\nexport function sortParticipants(\n  participants: Participant[],\n  localParticipant?: LocalParticipant\n) {\n  participants.sort((a, b) => {\n    // loudest speaker first\n    if (a.isSpeaking && b.isSpeaking) {\n      return b.audioLevel - a.audioLevel;\n    }\n\n    // speaker goes first\n    if (a.isSpeaking !== b.isSpeaking) {\n      if (a.isSpeaking) {\n        return -1;\n      } else {\n        return 1;\n      }\n    }\n\n    // last active speaker first\n    if (a.lastSpokeAt !== b.lastSpokeAt) {\n      const aLast = a.lastSpokeAt?.getTime() ?? 0;\n      const bLast = b.lastSpokeAt?.getTime() ?? 0;\n      return bLast - aLast;\n    }\n\n    // video on\n    const aVideo = a.videoTracks.size > 0;\n    const bVideo = b.videoTracks.size > 0;\n    if (aVideo !== bVideo) {\n      if (aVideo) {\n        return -1;\n      } else {\n        return 1;\n      }\n    }\n\n    // joinedAt\n    return (a.joinedAt?.getTime() ?? 0) - (b.joinedAt?.getTime() ?? 0);\n  });\n\n  if (localParticipant) {\n    const localIdx = participants.indexOf(localParticipant);\n    if (localIdx >= 0) {\n      participants.splice(localIdx, 1);\n      if (participants.length > 0) {\n        participants.splice(1, 0, localParticipant);\n      } else {\n        participants.push(localParticipant);\n      }\n    }\n  }\n}\n","import { ConnectOptions, Participant, Room } from \"livekit-client\";\nimport React, { useEffect } from \"react\";\nimport { ControlsProps } from \"./components/ControlsView\";\nimport { ParticipantProps } from \"./components/ParticipantView\";\nimport { StageProps } from \"./components/StageProps\";\nimport { StageView } from \"./components/StageView\";\nimport { useRoom } from \"./useRoom\";\n\nexport interface RoomProps {\n  url: string;\n  token: string;\n  connectOptions?: ConnectOptions;\n  // override default participant sort\n  sortParticipants?: (participants: Participant[]) => void;\n  /**\n   * when set to true, optimize bandwidth (and room capacity) by\n   * * disabling receiving video when participant is hidden\n   * * use lower quality video when participant is displayed as thumbnail\n   */\n  adaptiveVideo?: Boolean;\n  // when first connected to room\n  onConnected?: (room: Room) => void;\n  // when user leaves the room\n  onLeave?: (room: Room) => void;\n  stageRenderer?: (props: StageProps) => React.ReactElement | null;\n  participantRenderer?: (props: ParticipantProps) => React.ReactElement | null;\n  controlRenderer?: (props: ControlsProps) => React.ReactElement | null;\n}\n\nexport const LiveKitRoom = ({\n  url,\n  token,\n  connectOptions,\n  sortParticipants,\n  stageRenderer,\n  participantRenderer,\n  controlRenderer,\n  onConnected,\n  onLeave,\n  adaptiveVideo,\n}: RoomProps) => {\n  const roomState = useRoom({ sortParticipants });\n\n  useEffect(() => {\n    roomState.connect(url, token, connectOptions).then((room) => {\n      if (!room) {\n        return;\n      }\n      if (onConnected) {\n        onConnected(room);\n      }\n      return () => {\n        room.disconnect();\n      };\n    });\n  }, []);\n\n  const selectedStageRenderer = stageRenderer ?? StageView;\n\n  return selectedStageRenderer({\n    roomState,\n    participantRenderer,\n    controlRenderer,\n    onLeave,\n    adaptiveVideo,\n  });\n};\n","import { faBolt } from '@fortawesome/free-solid-svg-icons'\nimport { createLocalVideoTrack, CreateVideoTrackOptions, LocalVideoTrack } from 'livekit-client'\nimport { AudioSelectButton, ControlButton, VideoRenderer, VideoSelectButton } from 'livekit-react'\nimport React, { ReactElement, useEffect, useRef, useState } from \"react\"\nimport AspectRatio from 'react-aspect-ratio'\nimport { useHistory } from 'react-router-dom'\n\nexport const PreJoinPage = () => {\n  // state to pass onto room\n  const [url, setUrl] = useState('ws://localhost:7880')\n  const [token, setToken] = useState<string>('')\n  const [simulcast, setSimulcast] = useState(false)\n  const [videoEnabled, setVideoEnabled] = useState(false)\n  const [audioEnabled, setAudioEnabled] = useState(true)\n  // disable connect button unless validated\n  const [connectDisabled, setConnectDisabled] = useState(true)\n  const videoRef = useRef<HTMLVideoElement>(null);\n  const [videoTrack, setVideoTrack] = useState<LocalVideoTrack>();\n  const [audioDevice, setAudioDevice] = useState<MediaDeviceInfo>();\n  const [videoDevice, setVideoDevice] = useState<MediaDeviceInfo>();\n  const history = useHistory()\n\n  useEffect(() => {\n    if (!videoRef.current || !videoTrack) {\n      return\n    }\n    const videoEl = videoRef.current;\n    videoTrack.attach(videoEl)\n    return () => {\n      videoTrack.detach(videoEl)\n      videoTrack.stop()\n    }\n  }, [videoTrack, videoRef])\n\n  useEffect(() => {\n    if (token && url) {\n      setConnectDisabled(false)\n    } else {\n      setConnectDisabled(true)\n    }\n  }, [token, url])\n\n  const toggleVideo = () => {\n    if (videoTrack) {\n      videoTrack.stop()\n      setVideoEnabled(false)\n      setVideoTrack(undefined)\n    } else {\n      const options: CreateVideoTrackOptions = {}\n      if (videoDevice) {\n        options.deviceId = videoDevice.deviceId\n      }\n      createLocalVideoTrack(options).then((track) => {\n        setVideoEnabled(true)\n        setVideoTrack(track)\n      })\n    }\n  }\n\n  useEffect(() => {\n    // enable video by default\n    createLocalVideoTrack().then((track) => {\n      setVideoEnabled(true)\n      setVideoTrack(track)\n    })\n  }, [])\n\n  const toggleAudio = () => {\n    if (audioEnabled) {\n      setAudioEnabled(false)\n    } else {\n      setAudioEnabled(true)\n    }\n  }\n\n  const selectVideoDevice = (device: MediaDeviceInfo) => {\n    setVideoDevice(device);\n    if (videoTrack) {\n      if (videoTrack.mediaStreamTrack.getSettings().deviceId === device.deviceId) {\n        return\n      }\n      // stop video\n      toggleVideo();\n    }\n\n    // start video with correct device\n    toggleVideo();\n  }\n\n  const connectToRoom = () => {\n    if (window.location.protocol === 'https:' &&\n        url.startsWith('ws://') && !url.startsWith('ws://localhost')) {\n      alert('Unable to connect to insecure websocket from https');\n      return\n    }\n\n    const params: {[key: string]: string} = {\n      url,\n      token,\n      videoEnabled: videoEnabled ? '1' : '0',\n      audioEnabled: audioEnabled ? '1' : '0',\n      simulcast: simulcast ? '1' : '0',\n    }\n    if (audioDevice) {\n      params.audioDeviceId = audioDevice.deviceId;\n    }\n    if (videoDevice) {\n      params.videoDeviceId = videoDevice.deviceId;\n    }\n    history.push({\n      pathname: '/room',\n      search: \"?\" + new URLSearchParams(params).toString()\n    })\n  }\n\n  let videoElement: ReactElement;\n  if (videoTrack) {\n    videoElement = <VideoRenderer track={videoTrack} isLocal={true} />;\n  } else {\n    videoElement = <div className=\"placeholder\"/>\n  }\n\n  return (\n    <div className=\"prejoin\">\n      <main>\n        <h2>LiveKit Video</h2>\n        <hr/>\n        <div className=\"entrySection\">\n          <div>\n            <div className=\"label\">\n              LiveKit URL\n            </div>\n            <div>\n              <input type=\"text\" name=\"url\" value={url} onChange={e => setUrl(e.target.value)} />\n            </div>\n          </div>\n          <div>\n            <div className=\"label\">\n              Token\n            </div>\n            <div>\n              <input type=\"text\" name=\"token\" value={token} onChange={e => setToken(e.target.value)} />\n            </div>\n          </div>\n          <div>\n            <input type=\"checkbox\" name=\"simulcast\" checked={simulcast} onChange={e => setSimulcast(e.target.checked)}/>\n            <label>Simulcast</label>\n          </div>\n        </div>\n\n        <div className=\"videoSection\">\n          <AspectRatio ratio={16 / 9}>\n            {videoElement}\n          </AspectRatio>\n        </div>\n\n        <div className=\"controlSection\">\n          <div>\n            <AudioSelectButton\n              isMuted={!audioEnabled}\n              onClick={toggleAudio}\n              onSourceSelected={setAudioDevice}\n              />\n            <VideoSelectButton\n              isEnabled={videoTrack !== undefined}\n              onClick={toggleVideo}\n              onSourceSelected={selectVideoDevice}\n            />\n          </div>\n          <div className=\"right\">\n            <ControlButton\n              label=\"Connect\"\n              disabled={connectDisabled}\n              icon={faBolt}\n              onClick={connectToRoom}/>\n          </div>\n        </div>\n      </main>\n      <footer>\n        This page is built with <a href=\"https://github.com/livekit/livekit-react\">LiveKit React</a>&nbsp;\n        (<a href=\"https://github.com/livekit/livekit-react/blob/master/example/src/PreJoinPage.tsx\">source</a>)\n      </footer>\n    </div>\n  )\n}\n","import { faUserFriends } from '@fortawesome/free-solid-svg-icons'\nimport { FontAwesomeIcon } from '@fortawesome/react-fontawesome'\nimport { CreateAudioTrackOptions, createLocalAudioTrack, createLocalVideoTrack, CreateVideoTrackOptions, Room, RoomEvent, TrackPublishOptions } from 'livekit-client'\nimport { LiveKitRoom } from 'livekit-react'\nimport React, { useState } from \"react\"\nimport \"react-aspect-ratio/aspect-ratio.css\"\nimport { useHistory, useLocation } from 'react-router-dom'\n\nexport const RoomPage = () => {\n  const [numParticipants, setNumParticipants] = useState(0)\n  const history = useHistory()\n  const query = new URLSearchParams(useLocation().search)\n  const url = query.get('url')\n  const token = query.get('token')\n  const recorder = query.get('recorder')\n\n  if (!url || !token) {\n    return (\n      <div>\n        url and token are required\n      </div>\n    )\n  }\n\n  const onLeave = () => {\n    history.push({\n      pathname: '/',\n    })\n  }\n\n  const updateParticipantSize = (room: Room) => {\n    setNumParticipants(room.participants.size + 1);\n  }\n\n  const onParticipantDisconnected = (room: Room) => {\n    updateParticipantSize(room)\n    \n    /* Special rule for recorder */\n    if (recorder && parseInt(recorder, 10) === 1 && room.participants.size === 0) {\n      console.log(\"END_RECORDING\")\n    }\n  }\n\n  return (\n    <div className=\"roomContainer\">\n      <div className=\"topBar\">\n        <h2>LiveKit Video</h2>\n        <div className=\"participantCount\">\n          <FontAwesomeIcon icon={faUserFriends} />\n          <span>{numParticipants}</span>\n        </div>\n      </div>\n      <LiveKitRoom\n        url={url}\n        token={token}\n        onConnected={room => {\n          onConnected(room, query);\n          room.on(RoomEvent.ParticipantConnected, () => updateParticipantSize(room))\n          room.on(RoomEvent.ParticipantDisconnected, () => onParticipantDisconnected(room))\n          updateParticipantSize(room);\n        }}\n        onLeave={onLeave}\n        adaptiveVideo={true}\n      />\n    </div>\n  )\n}\n\nasync function onConnected(room: Room, query: URLSearchParams) {\n  // make it easier to debug\n  (window as any).currentRoom = room;\n\n  if (isSet(query, 'audioEnabled')) {\n    const options: CreateAudioTrackOptions = {}\n    const audioDeviceId = query.get('audioDeviceId');\n    if (audioDeviceId) {\n      options.deviceId = audioDeviceId;\n    }\n    const audioTrack = await createLocalAudioTrack(options)\n    await room.localParticipant.publishTrack(audioTrack)\n  }\n  if (isSet(query, 'videoEnabled')) {\n    const videoDeviceId = query.get('videoDeviceId');\n    const captureOptions: CreateVideoTrackOptions = {}\n    if (videoDeviceId) {\n      captureOptions.deviceId = videoDeviceId;\n    }\n    const videoTrack = await createLocalVideoTrack(captureOptions);\n    const publishOptions: TrackPublishOptions = {\n      name: 'camera'\n    }\n    if (isSet(query, 'simulcast')) {\n      publishOptions.simulcast = true\n    }\n    await room.localParticipant.publishTrack(videoTrack, publishOptions)\n  }\n}\n\nfunction isSet(query: URLSearchParams, key: string): boolean {\n  return query.get(key) === '1' || query.get(key) === 'true'\n}","import 'livekit-react/dist/index.css'\nimport React from 'react'\nimport { HashRouter as Router, Route, Switch } from 'react-router-dom'\nimport { PreJoinPage } from './PreJoinPage'\nimport { RoomPage } from './RoomPage'\n\nconst App = () => {\n  return (\n    <div className=\"container\">\n      <Router>\n        <Switch>\n          <Route path=\"/room\">\n            <RoomPage/>\n          </Route>\n          <Route path=\"/\">\n            <PreJoinPage/>\n          </Route>\n        </Switch>\n      </Router>\n    </div>\n  )\n}\n\nexport default App\n","import './index.css'\n\nimport React from 'react'\nimport ReactDOM from 'react-dom'\nimport App from './App'\n\nReactDOM.render(<App />, document.getElementById('root'))\n"],"sourceRoot":""}